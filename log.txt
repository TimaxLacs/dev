Listening 38997 port
call options {
  code: '\n' +
    'async ({ deep, require, gql, data: { newLink } }) => {\n' +
    "    const ts = require('typescript');\n" +
    '  const { data: [generatedFrom] } = await deep.select({\n' +
    "      type_id: await deep.id('@deep-foundation/core', 'GeneratedFrom'),\n" +
    '    to_id: newLink.id, \n' +
    '  });\n' +
    '  const value = newLink?.value?.value;\n' +
    "  let compiledString = '';\n" +
    '  if (value) {\n' +
    '    const result = ts.transpileModule(value, {\n' +
    '      "compilerOptions": {\n' +
    '        "allowSyntheticDefaultImports": true,\n' +
    '        "experimentalDecorators": true,\n' +
    '        "inlineSourceMap": true,\n' +
    '        inlineSources: true,\n' +
    '        "noImplicitAny": false,\n' +
    '        "removeComments": true,\n' +
    '        "jsx": "react",\n' +
    '        "module": "ESNext",\n' +
    '        "moduleResolution": "node",\n' +
    '        "target": "ESNext",\n' +
    '        "skipLibCheck": true,\n' +
    '        "resolveJsonModule": true,\n' +
    '        "esModuleInterop": true,\n' +
    '        "isolatedModules": true\n' +
    '      }\n' +
    '    });\n' +
    '    if (!result.outputText) {\n' +
    '      throw result;\n' +
    '    }\n' +
    "    compiledString = result.outputText || '';\n" +
    '  }\n' +
    '  if (!generatedFrom) {\n' +
    '      await deep.insert({\n' +
    "        type_id: await deep.id('@deep-foundation/core', 'GeneratedFrom'),\n" +
    '      to_id: newLink.id,\n' +
    '      in: { data: {\n' +
    "          type_id: await deep.id('@deep-foundation/core', 'Contain'),\n" +
    '        from_id: newLink.id,\n' +
    '      } },\n' +
    '      from: { data: {\n' +
    "          type_id: await deep.id('@deep-foundation/core', 'SyncTextFile'),\n" +
    '        string: { data: { value: compiledString } },\n' +
    '        in: { data: {\n' +
    "            type_id: await deep.id('@deep-foundation/core', 'Contain'),\n" +
    '          from_id: newLink.id,\n' +
    "          string: { data: { value: 'generated' } },\n" +
    '        } },\n' +
    '      } },\n' +
    '    });\n' +
    '  } else {\n' +
    '      await deep.update({\n' +
    '        link_id: { _eq: generatedFrom.from_id },\n' +
    '    }, {\n' +
    '        value: compiledString,\n' +
    "    }, { table: 'strings' });\n" +
    '  }\n' +
    '}\n',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 38997,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiNzE5In0sImlhdCI6MTcxOTQxNDQ3MX0.eDUre2w9LzVk1BObpuOLTaHaacO61E7mQX26C9kr5BY',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: null,
    oldLink: {
      id: 803,
      from_id: 0,
      type_id: 715,
      to_id: 0,
      __typename: 'links',
      value: [Object]
    },
    newLink: {
      id: 803,
      from_id: 0,
      type_id: 715,
      to_id: 0,
      __typename: 'links',
      value: [Object]
    },
    promiseId: 2181,
    deeplinksUrl: 'https://3006-deepfoundation-dev-xjm42adwb5e.ws-eu114.gitpod.io'
  }
}
call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc1OSJ9LCJpYXQiOjE3MTk0MTQ0NzV9.lh_h4ZAjvZB0j3kFJLZSbw9jhH0imDPdc7uVqb7b3Lg',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1745,
    routeId: 1748,
    router: 1746
  }
}
http call result undefined
