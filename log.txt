Listening 40571 port
call options {
  code: '\n' +
    'async ({ deep, require, gql, data: { newLink } }) => {\n' +
    "    const ts = require('typescript');\n" +
    '  const { data: [generatedFrom] } = await deep.select({\n' +
    "      type_id: await deep.id('@deep-foundation/core', 'GeneratedFrom'),\n" +
    '    to_id: newLink.id, \n' +
    '  });\n' +
    '  const value = newLink?.value?.value;\n' +
    "  let compiledString = '';\n" +
    '  if (value) {\n' +
    '    const result = ts.transpileModule(value, {\n' +
    '      "compilerOptions": {\n' +
    '        "allowSyntheticDefaultImports": true,\n' +
    '        "experimentalDecorators": true,\n' +
    '        "inlineSourceMap": true,\n' +
    '        inlineSources: true,\n' +
    '        "noImplicitAny": false,\n' +
    '        "removeComments": true,\n' +
    '        "jsx": "react",\n' +
    '        "module": "ESNext",\n' +
    '        "moduleResolution": "node",\n' +
    '        "target": "ESNext",\n' +
    '        "skipLibCheck": true,\n' +
    '        "resolveJsonModule": true,\n' +
    '        "esModuleInterop": true,\n' +
    '        "isolatedModules": true\n' +
    '      }\n' +
    '    });\n' +
    '    if (!result.outputText) {\n' +
    '      throw result;\n' +
    '    }\n' +
    "    compiledString = result.outputText || '';\n" +
    '  }\n' +
    '  if (!generatedFrom) {\n' +
    '      await deep.insert({\n' +
    "        type_id: await deep.id('@deep-foundation/core', 'GeneratedFrom'),\n" +
    '      to_id: newLink.id,\n' +
    '      in: { data: {\n' +
    "          type_id: await deep.id('@deep-foundation/core', 'Contain'),\n" +
    '        from_id: newLink.id,\n' +
    '      } },\n' +
    '      from: { data: {\n' +
    "          type_id: await deep.id('@deep-foundation/core', 'SyncTextFile'),\n" +
    '        string: { data: { value: compiledString } },\n' +
    '        in: { data: {\n' +
    "            type_id: await deep.id('@deep-foundation/core', 'Contain'),\n" +
    '          from_id: newLink.id,\n' +
    "          string: { data: { value: 'generated' } },\n" +
    '        } },\n' +
    '      } },\n' +
    '    });\n' +
    '  } else {\n' +
    '      await deep.update({\n' +
    '        link_id: { _eq: generatedFrom.from_id },\n' +
    '    }, {\n' +
    '        value: compiledString,\n' +
    "    }, { table: 'strings' });\n" +
    '  }\n' +
    '}\n',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiNzE5In0sImlhdCI6MTcyMDA2ODc5OX0.qn57c2-j2Tuuyg3zvqzveCF0Pk_lvWdp0W99Ljo26Xk',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: null,
    oldLink: {
      id: 803,
      from_id: 0,
      type_id: 715,
      to_id: 0,
      __typename: 'links',
      value: [Object]
    },
    newLink: {
      id: 803,
      from_id: 0,
      type_id: 715,
      to_id: 0,
      __typename: 'links',
      value: [Object]
    },
    promiseId: 16510,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTQ3MSJ9LCJpYXQiOjE3MjAwNjg4MTN9.1ki85v0vemVWs8kRhrpr8RrVb7OhhPrl9Mgmzg8uuJQ',
  code: 'async (req, res, next, { deep, require, data: { baseUrl, originalUrl, path } }) => {\n' +
    "    const { DeepClient } = await import('@deep-foundation/deeplinks/imports/client.js');\n" +
    '\n' +
    "    const User = deep.idLocal('@deep-foundation/core', 'User');\n" +
    "    const Join = deep.idLocal('@deep-foundation/core', 'Join');\n" +
    "    const Contain = deep.idLocal('@deep-foundation/core', 'Contain');\n" +
    "    const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "    const Reply = await deep.id('@deep-foundation/messaging', 'Reply');\n" +
    "    const Conversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    '\n' +
    "    const HandleTelegramBotIn = await deep.id('@deep-foundation/telegram-bot', 'HandleTelegramBotIn');\n" +
    '\n' +
    '    const m = req?.body?.message || req?.body?.callback_query?.message;\n' +
    '    const _message_id = m?.message_id;\n' +
    '    const _date = m?.date;\n' +
    '    const _message = m?.text;\n' +
    '    const _voice = m?.voice;\n' +
    '    const _audio = m?.audio;\n' +
    '    const _userId = m?.from?.id;\n' +
    '    const _is_bot = m?.from?.is_bot;\n' +
    '    const _username = m?.from?.username;\n' +
    '    const _conversationId = m?.chat?.id;\n' +
    '    const _replyId = m?.reply_to_message?.message_id;\n' +
    '\n' +
    "    const botId = +baseUrl.split('/').slice(-1)[0];\n" +
    '    \n' +
    '    // found or insert user based on telegram nick\n' +
    '    let userId;\n' +
    '    userId = (await deep.select({\n' +
    '        type_id: User,\n' +
    '        in: {\n' +
    '            type_id: Contain, from_id: botId,\n' +
    '            string: { value: `${_userId}` },\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    if (!userId) {\n' +
    '        userId = (await deep.insert({\n' +
    '            type_id: User,\n' +
    '            out: { data: [\n' +
    '                {\n' +
    '                    type_id: Join,\n' +
    "                    to_id: await deep.id('deep', 'users'),\n" +
    '                },\n' +
    '                {\n' +
    '                    type_id: Join,\n' +
    '                    to_id: botId,\n' +
    '                },\n' +
    '            ] },\n' +
    '            in: { data: {\n' +
    '                type_id: Contain, from_id: botId,\n' +
    '                string: { data: { value: `${_userId}` } }, // telegram nick\n' +
    '            } },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '    }\n' +
    '\n' +
    '    const udeep = new DeepClient({ deep, ...(await deep.jwt({ linkId: userId })) });\n' +
    '\n' +
    '    // found or insert user based on telegram nick\n' +
    '    let conversationId;\n' +
    '    conversationId = (await deep.select({\n' +
    '        type_id: Conversation,\n' +
    '        in: {\n' +
    '            type_id: Contain, from_id: userId,\n' +
    '            string: { value: `${_conversationId}` },\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    if (!conversationId) {\n' +
    '        conversationId = (await deep.insert({\n' +
    '            type_id: Conversation,\n' +
    '            in: { data: {\n' +
    '                type_id: Contain, from_id: userId,\n' +
    '                string: { data: { value: `${_conversationId}` } }, // telegram conversation id\n' +
    '            } },\n' +
    '            out: { data: {\n' +
    '                type_id: Reply,\n' +
    '                to_id: botId,\n' +
    '                in: { data: {\n' +
    '                    type_id: Contain, from_id: userId,\n' +
    '                } },\n' +
    '            } },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '    }\n' +
    '\n' +
    '    const { data: handles } = await deep.select({\n' +
    '        type_id: HandleTelegramBotIn,\n' +
    '        from_id: botId,\n' +
    "        order_by: { id: 'asc' },\n" +
    '    });\n' +
    '\n' +
    '    const state = {\n' +
    '        defaultHandling: true,\n' +
    '    };\n' +
    '    const handled = {};\n' +
    '    for (let h in handles) {\n' +
    '        const packageId = (await deep.select({\n' +
    '            out: { type_id: Contain, to_id: handles[h].to_id },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        if (!packageId) {\n' +
    '            handled[handles[h].to_id] = { error: `!packageId by handler(${handles[h].to_id}).in(Contain).from` };\n' +
    '            continue;\n' +
    '        }\n' +
    '        const hdeep = new deep.DeepClient({\n' +
    '            deep, ...(await deep.jwt({ linkId: packageId }))\n' +
    '        });\n' +
    '        handled[handles[h].to_id] = await hdeep.eval({\n' +
    '            linkId: botId,\n' +
    '            handlerId: handles[h].to_id,\n' +
    '            input: {\n' +
    '                data: {\n' +
    '                    state,\n' +
    '                    req, res,\n' +
    '                    botId,\n' +
    '                    userId,\n' +
    '                    conversationId,\n' +
    '                    handlerId: handles[h].to_id,\n' +
    '                    udeep,\n' +
    '                },\n' +
    '            },\n' +
    '        });\n' +
    '    }\n' +
    '\n' +
    '    if (state.defaultHandling) {\n' +
    '        // found or insert user based on telegram nick\n' +
    '        let replyId = conversationId; // if not exists, then convers\n' +
    '        if (_replyId) replyId = (await deep.select({ \n' +
    '            type_id: Contain,\n' +
    '            string: { value: `${_replyId}` },\n' +
    '        }))?.data?.[0]?.to_id;\n' +
    '        const messageInserted = await udeep.insert({\n' +
    '            type_id: Message,\n' +
    '            string: { data: { value: _message } },\n' +
    '            in: { data: {\n' +
    '                type_id: Contain, from_id: userId,\n' +
    '                string: { data: { value: `${_message_id}` } },\n' +
    '            } },\n' +
    '            out: { data: {\n' +
    '                type_id: Reply,\n' +
    '                to_id: replyId,\n' +
    '                in: { data: {\n' +
    '                    type_id: Contain, from_id: userId,\n' +
    '                } },\n' +
    '            } },\n' +
    '        });\n' +
    '        const { data: messageId } = messageInserted;\n' +
    '        res.send(JSON.stringify({\n' +
    '            userId,\n' +
    '            conversationId,\n' +
    '            messageId,\n' +
    '        }));\n' +
    '    }\n' +
    '}',
  data: {
    routeString: '/packages/deep-foundation/telegram-bot/1613',
    path: '/http-call',
    originalUrl: '/packages/deep-foundation/telegram-bot/1613',
    baseUrl: '/packages/deep-foundation/telegram-bot/1613',
    handlerId: 1439,
    routeId: 16405,
    router: 1469
  }
}
evalClientHandler value async ({ deep, data: {
    state,
    req, res,
    botId,
    userId,
    conversationId,
    handlerId,
    udeep,
}, require }) => {
    const Active = await deep.id('@deep-foundation/deepmemorybot', 'Active');
    const Contain = await deep.id('@deep-foundation/core', 'Contain');
    const Message = await deep.id('@deep-foundation/messaging', 'Message');
    const Reply = await deep.id('@deep-foundation/messaging', 'Reply');

    const reader = await deep.id('@deep-foundation/deepmemorybot', 'reader');
    const executor = await deep.id('@deep-foundation/deepmemorybot', 'executor');

    const { serializeError } = await deep.import('serialize-error');

    const edeep = new deep.DeepClient({
        deep, ...(await deep.jwt({ linkId: executor }))
    });

    if (req?.body?.callback_query?.data) {
        const data = JSON.parse(req?.body?.callback_query?.data);
        if (data.messageId) {
            state.defaultHandling = false;
            const { data: [active] } = await edeep.select({
                type_id: Active,
                to_id: botId,
            });
            if (!active) return { error: '!active' }
            let result;
            try {
                result = await edeep.eval({
                    linkId: data.messageId,
                    handlerId: data.handlerId,
                });
                if (result.error) result.error = serializeError(result.error);
            } catch(error) {
                result = { error: serializeError(error) };
            }
            const { data: [reply] } = await edeep.insert({
                type_id: Reply,
                from: { data: {
                    type_id: Message,
                    string: { data: { value: `${JSON.stringify(result, null, 2)}` } },
                    in: { data: {
                        type_id: Contain,
                        from_id: executor,
                    } },
                } },
                to_id: data.messageId,
                in: { data: {
                    type_id: Contain,
                    from_id: executor,
                } },
            });
            if (reply) await deep.await(reply.id);
            res.send(JSON.stringify({
                userId: executor,
                replyId: reply.id,
                result,
            }));
        }
    }
}
IGNORED ERROR (ignore if you don't see other errors): Call to DeepClient.resolveDependency is failed with Error [ERR_REQUIRE_ESM]: require() of ES Module /node_modules/serialize-error/index.js from /index.js not supported.
Instead change the require of /node_modules/serialize-error/index.js in /index.js to a dynamic import() which is available in all CommonJS modules.
    at DeepClient.requireWrapper [as resolveDependency] (file:///index.js:28:12)
    at DeepClient.<anonymous> (file:///node_modules/@deep-foundation/deeplinks/imports/client.js:954:45)
    at Generator.next (<anonymous>)
    at file:///node_modules/@deep-foundation/deeplinks/imports/client.js:7:71
    at new Promise (<anonymous>)
    at __awaiter (file:///node_modules/@deep-foundation/deeplinks/imports/client.js:3:12)
    at DeepClient.import (file:///node_modules/@deep-foundation/deeplinks/imports/client.js:951:16)
    at eval (eval at <anonymous> (file:///node_modules/@deep-foundation/deeplinks/imports/client-handler.js:16:32), <anonymous>:18:49) {
  code: 'ERR_REQUIRE_ESM'
}
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId }, require }) => {\n' +
    "    const { Telegraf } = require('telegraf');\n" +
    "    const Markup = require('telegraf/markup');\n" +
    '\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/telegram-bot', 'Active');\n" +
    "    const Conversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    const HandleTelegramBotOut = await deep.id('@deep-foundation/telegram-bot', 'HandleTelegramBotOut');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    const Contain = deep.idLocal('@deep-foundation/core', 'Contain');\n" +
    '\n' +
    '    function splitStringIntoChunks(str, chunkSize = 4096) {\n' +
    '        const chunks = [];\n' +
    '        for (let i = 0, len = str.length; i < len; i += chunkSize) {\n' +
    '            chunks.push(str.substring(i, i + chunkSize));\n' +
    '        }\n' +
    '        return chunks;\n' +
    '    }\n' +
    '\n' +
    '    const botId = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    if (!botId) {\n' +
    '        const botId = (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const token = (await deep.select({\n' +
    '            type_id: Token,\n' +
    '            in: {\n' +
    '                type_id: Active,\n' +
    '                from: {\n' +
    '                    down: {\n' +
    '                        tree_id: messagingTree,\n' +
    '                        link_id: newLink.id,\n' +
    '                    },\n' +
    '                },\n' +
    '            },\n' +
    '        }))?.data?.[0];\n' +
    '        const conversationId = (await deep.select({\n' +
    '            type_id: Conversation,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const replyToId = newLink.to_id;\n' +
    '\n' +
    '        const message = (await deep.select(newLink.from_id))?.data?.[0];\n' +
    '\n' +
    '        const bot = new Telegraf(token?.value?.value);\n' +
    '\n' +
    '        const { data: handles } = await deep.select({\n' +
    '            type_id: HandleTelegramBotOut,\n' +
    '            from_id: botId,\n' +
    "            order_by: { id: 'asc' },\n" +
    '        });\n' +
    '\n' +
    '        const state = {\n' +
    '            defaultHandling: true,\n' +
    '        };\n' +
    '        const handled = {};\n' +
    '        for (let h in handles) {\n' +
    '            const packageId = (await deep.select({\n' +
    '                out: { type_id: Contain, to_id: handles[h].to_id },\n' +
    '            }))?.data?.[0]?.id;\n' +
    '            if (!packageId) {\n' +
    '                handled[handles[h].to_id] = { error: `!packageId by handler(${handles[h].to_id}).in(Contain).from` };\n' +
    '                continue;\n' +
    '            }\n' +
    '            const hdeep = new deep.DeepClient({\n' +
    '                deep, ...(await deep.jwt({ linkId: packageId }))\n' +
    '            })\n' +
    '            handled[handles[h].to_id] = await hdeep.eval({\n' +
    '                linkId: botId,\n' +
    '                handlerId: handles[h].to_id,\n' +
    '                input: {\n' +
    '                    data: {\n' +
    '                        state,\n' +
    '                        bot,\n' +
    '                        botId,\n' +
    '                        userId: triggeredByLinkId,\n' +
    '                        conversationId,\n' +
    '                        handlerId: handles[h].to_id,\n' +
    '                        reply: newLink,\n' +
    '                        message,\n' +
    '                    },\n' +
    '                },\n' +
    '            });\n' +
    '        }\n' +
    '\n' +
    '        if (state.defaultHandling) {\n' +
    '            const chanks = splitStringIntoChunks(message?.value?.value);\n' +
    '            for (let c in chanks) {\n' +
    '                bot.telegram.sendMessage(\n' +
    '                    await deep.name(conversationId),\n' +
    '                    chanks[c],\n' +
    '                );\n' +
    '            }\n' +
    '        }\n' +
    '\n' +
    '        return {\n' +
    '            botId,\n' +
    '            conversationId,\n' +
    '            replyToId,\n' +
    '            message,\n' +
    '            token,\n' +
    '        };\n' +
    '    } else {\n' +
    '        return { botId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTQ3MSJ9LCJpYXQiOjE3MjAwNjg4Mjl9.VKKxXFliGXYzcxWHUwTxmS8zkmKoxmRy6C3_j3EeRzA',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1471,
    oldLink: null,
    newLink: {
      from_id: 16519,
      type_id: 1096,
      id: 16521,
      to_id: 1613,
      value: null
    },
    promiseId: 16522,
    selectorId: 1453,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
http call result undefined
evalClientHandler value async ({ deep, data: {
    state,
    bot,
    botId,
    userId,
    conversationId,
    handlerId,
    reply,
    message,
} }) => {
    if ((message?.value?.value || '').includes('DEEP_MEMORY_EXECUTE')) {
        const codeMatch = message?.value?.value.matchAll(/```javascript([\s\S]*?)```/g);
        const codes = [...codeMatch].map(c => c[1].trim());
        for (let c in codes) {
            const { data: [{ id: newHandlerId }] } = await deep.insert({
                type_id: deep.idLocal('@deep-foundation/core', 'Handler'),
                to: { data: {
                    type_id: deep.idLocal('@deep-foundation/core', 'SyncTextFile'),
                    string: { data: { value: `async ({ deep, sql }) => { ${codes[c]} }` } },
                    in: { data: {
                        type_id: deep.idLocal('@deep-foundation/core', 'Contain'),
                        from_id: await deep.id('@deep-foundation/deepmemorybot', 'executor'),
                    } },
                } },
                from_id: 83,
                in: { data: {
                    type_id: deep.idLocal('@deep-foundation/core', 'Contain'),
                    from_id: await deep.id('@deep-foundation/deepmemorybot', 'executor'),
                } },
            });
            bot.telegram.sendMessage(
                await deep.name(conversationId),
                codes[c],
                { reply_markup: { inline_keyboard: [[
                    {
                        text: 'Execute',
                        callback_data: JSON.stringify({
                            messageId: message.id,
                            handlerId: newHandlerId,
                        }),
                    },
                ]] } },
            );
        }
    }
}
rejected {
  name: 'TypeError',
  message: "Cannot read properties of undefined (reading 'length')",
  stack: "TypeError: Cannot read properties of undefined (reading 'length')\n" +
    '    at splitStringIntoChunks (eval at memoized (/node_modules/lodash/memoize.js:62:23), <anonymous>:16:35)\n' +
    '    at eval (eval at memoized (/node_modules/lodash/memoize.js:62:23), <anonymous>:102:28)\n' +
    '    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)'
}
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId } }) => {\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/deepmemorybot', 'Active');\n" +
    "    const Contain = await deep.id('@deep-foundation/core', 'Contain');\n" +
    "    const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const Reply = await deep.id('@deep-foundation/messaging', 'Reply');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    var bConversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    var gptConversation = await deep.id('@deep-foundation/chatgpt-azure', 'Conversation');\n" +
    '\n' +
    "    const reader = await deep.id('@deep-foundation/deepmemorybot', 'reader');\n" +
    "    const executor = await deep.id('@deep-foundation/deepmemorybot', 'executor');\n" +
    '\n' +
    '    const botIdByContain = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    // found gpt convesations before\n' +
    '    var { data: [bconv] } = await deep.select({ type_id: bConversation, down: { tree_id: messagingTree, link_id: newLink.id } });\n' +
    '    const gptconv = bconv ? (await deep.select({\n' +
    '        type_id: gptConversation,\n' +
    '        down: {\n' +
    '            tree_id: messagingTree,\n' +
    '            link: {\n' +
    '                up: {\n' +
    '                    tree_id: messagingTree,\n' +
    '                    parent_id: bconv.id,\n' +
    '                },\n' +
    '            },\n' +
    '        },\n' +
    '    }))?.data?.[0] : undefined;\n' +
    '    // const conversationId = (await deep.select({\n' +
    '    //     type_id: Conversation,\n' +
    '    //     down: {\n' +
    '    //         tree_id: messagingTree,\n' +
    '    //         link_id: newLink.id,\n' +
    '    //     },\n' +
    '    // }))?.data?.[0]?.id;\n' +
    '    if (!!botIdByContain || triggeredByLinkId == reader || triggeredByLinkId == executor) {\n' +
    '        const botId = botIdByContain || (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    "        if (!botId) return { error: '!botId', botId, triggeredByLinkId, botIdByContain, executor, reader }\n" +
    '        const { data: [active] } = await deep.select({\n' +
    '            type_id: Active,\n' +
    '            to_id: botId,\n' +
    '        });\n' +
    "        if (!active) return { error: '!active', botId, triggeredByLinkId }\n" +
    '        const { data: [{ id }] } = await deep.insert({\n' +
    "            type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Apply'),\n" +
    "            from_id: await deep.id('@deep-foundation/deepmemorybot', 'template'),\n" +
    '            to_id: newLink.from_id,\n' +
    '            ...(gptconv ? {\n' +
    '                out: { data: {\n' +
    "                    type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Continue'),\n" +
    '                    to_id: gptconv.id,\n' +
    '                    in: { data: {\n' +
    '                        type_id: Contain,\n' +
    '                        from_id: active.id\n' +
    '                    } },\n' +
    '                } }\n' +
    '            } : {}),\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        const { data: [apply] } = await deep.select(id);\n' +
    '        \n' +
    '        const response = await new Promise(async (res, rej) => {\n' +
    '            let counter = 0;\n' +
    '            const interval = setInterval(async () => {\n' +
    '                const { data: [response] } = await deep.Traveler([apply])\n' +
    "                    .out({ type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Result') })\n" +
    "                    .to().in({ type_id: await deep.id('@deep-foundation/chatgpt-azure', 'Reply') }).from()\n" +
    '                    .select();\n' +
    '                if (response) res(response);\n' +
    '                else {\n' +
    '                    if (counter > 500) {\n' +
    '                        clearInterval(interval);\n' +
    '                        rej(new Error(`timeout ${counter} times`));\n' +
    '                    } else {\n' +
    '                        counter++;\n' +
    '                    }\n' +
    '                }\n' +
    '            }, 1000);\n' +
    '        });\n' +
    '\n' +
    "        if (!response) return { error: '!response' };\n" +
    '\n' +
    '        await deep.insert({\n' +
    '            type_id: Reply,\n' +
    '            from_id: response?.id,\n' +
    '            to_id: newLink.from_id,\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    } else {\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTU3OSJ9LCJpYXQiOjE3MjAwNjg4MzB9.uGG9zq-3zQmeTdZq2ZES4jXcJ1M_pg2WYJMDizit0aM',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1471,
    oldLink: null,
    newLink: {
      from_id: 16519,
      type_id: 1096,
      id: 16521,
      to_id: 1613,
      value: null
    },
    promiseId: 16524,
    selectorId: 1566,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
rejected {
  name: 'ReferenceError',
  message: 'botId is not defined',
  stack: 'ReferenceError: botId is not defined\n' +
    '    at eval (eval at memoized (/node_modules/lodash/memoize.js:62:23), <anonymous>:111:18)\n' +
    '    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)'
}
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId }, require }) => {\n' +
    "    const { Telegraf } = require('telegraf');\n" +
    "    const Markup = require('telegraf/markup');\n" +
    '\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/telegram-bot', 'Active');\n" +
    "    const Conversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    const HandleTelegramBotOut = await deep.id('@deep-foundation/telegram-bot', 'HandleTelegramBotOut');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    const Contain = deep.idLocal('@deep-foundation/core', 'Contain');\n" +
    '\n' +
    '    function splitStringIntoChunks(str, chunkSize = 4096) {\n' +
    '        const chunks = [];\n' +
    '        for (let i = 0, len = str.length; i < len; i += chunkSize) {\n' +
    '            chunks.push(str.substring(i, i + chunkSize));\n' +
    '        }\n' +
    '        return chunks;\n' +
    '    }\n' +
    '\n' +
    '    const botId = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    if (!botId) {\n' +
    '        const botId = (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const token = (await deep.select({\n' +
    '            type_id: Token,\n' +
    '            in: {\n' +
    '                type_id: Active,\n' +
    '                from: {\n' +
    '                    down: {\n' +
    '                        tree_id: messagingTree,\n' +
    '                        link_id: newLink.id,\n' +
    '                    },\n' +
    '                },\n' +
    '            },\n' +
    '        }))?.data?.[0];\n' +
    '        const conversationId = (await deep.select({\n' +
    '            type_id: Conversation,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const replyToId = newLink.to_id;\n' +
    '\n' +
    '        const message = (await deep.select(newLink.from_id))?.data?.[0];\n' +
    '\n' +
    '        const bot = new Telegraf(token?.value?.value);\n' +
    '\n' +
    '        const { data: handles } = await deep.select({\n' +
    '            type_id: HandleTelegramBotOut,\n' +
    '            from_id: botId,\n' +
    "            order_by: { id: 'asc' },\n" +
    '        });\n' +
    '\n' +
    '        const state = {\n' +
    '            defaultHandling: true,\n' +
    '        };\n' +
    '        const handled = {};\n' +
    '        for (let h in handles) {\n' +
    '            const packageId = (await deep.select({\n' +
    '                out: { type_id: Contain, to_id: handles[h].to_id },\n' +
    '            }))?.data?.[0]?.id;\n' +
    '            if (!packageId) {\n' +
    '                handled[handles[h].to_id] = { error: `!packageId by handler(${handles[h].to_id}).in(Contain).from` };\n' +
    '                continue;\n' +
    '            }\n' +
    '            const hdeep = new deep.DeepClient({\n' +
    '                deep, ...(await deep.jwt({ linkId: packageId }))\n' +
    '            })\n' +
    '            handled[handles[h].to_id] = await hdeep.eval({\n' +
    '                linkId: botId,\n' +
    '                handlerId: handles[h].to_id,\n' +
    '                input: {\n' +
    '                    data: {\n' +
    '                        state,\n' +
    '                        bot,\n' +
    '                        botId,\n' +
    '                        userId: triggeredByLinkId,\n' +
    '                        conversationId,\n' +
    '                        handlerId: handles[h].to_id,\n' +
    '                        reply: newLink,\n' +
    '                        message,\n' +
    '                    },\n' +
    '                },\n' +
    '            });\n' +
    '        }\n' +
    '\n' +
    '        if (state.defaultHandling) {\n' +
    '            const chanks = splitStringIntoChunks(message?.value?.value);\n' +
    '            for (let c in chanks) {\n' +
    '                bot.telegram.sendMessage(\n' +
    '                    await deep.name(conversationId),\n' +
    '                    chanks[c],\n' +
    '                );\n' +
    '            }\n' +
    '        }\n' +
    '\n' +
    '        return {\n' +
    '            botId,\n' +
    '            conversationId,\n' +
    '            replyToId,\n' +
    '            message,\n' +
    '            token,\n' +
    '        };\n' +
    '    } else {\n' +
    '        return { botId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTQ3MSJ9LCJpYXQiOjE3MjAwNjg4MzB9.x5RvVXLyR_HX8nVxXkiHV0HPplhTi9Dn4CVb_4fV3p8',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 16515,
    oldLink: null,
    newLink: {
      from_id: 16527,
      type_id: 1096,
      id: 16529,
      to_id: 16519,
      value: null
    },
    promiseId: 16530,
    selectorId: 1453,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
call result { botId: 1613 }
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId } }) => {\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/deepmemorybot', 'Active');\n" +
    "    const Contain = await deep.id('@deep-foundation/core', 'Contain');\n" +
    "    const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const Reply = await deep.id('@deep-foundation/messaging', 'Reply');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    var bConversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    var gptConversation = await deep.id('@deep-foundation/chatgpt-azure', 'Conversation');\n" +
    '\n' +
    "    const reader = await deep.id('@deep-foundation/deepmemorybot', 'reader');\n" +
    "    const executor = await deep.id('@deep-foundation/deepmemorybot', 'executor');\n" +
    '\n' +
    '    const botIdByContain = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    // found gpt convesations before\n' +
    '    var { data: [bconv] } = await deep.select({ type_id: bConversation, down: { tree_id: messagingTree, link_id: newLink.id } });\n' +
    '    const gptconv = bconv ? (await deep.select({\n' +
    '        type_id: gptConversation,\n' +
    '        down: {\n' +
    '            tree_id: messagingTree,\n' +
    '            link: {\n' +
    '                up: {\n' +
    '                    tree_id: messagingTree,\n' +
    '                    parent_id: bconv.id,\n' +
    '                },\n' +
    '            },\n' +
    '        },\n' +
    '    }))?.data?.[0] : undefined;\n' +
    '    // const conversationId = (await deep.select({\n' +
    '    //     type_id: Conversation,\n' +
    '    //     down: {\n' +
    '    //         tree_id: messagingTree,\n' +
    '    //         link_id: newLink.id,\n' +
    '    //     },\n' +
    '    // }))?.data?.[0]?.id;\n' +
    '    if (!!botIdByContain || triggeredByLinkId == reader || triggeredByLinkId == executor) {\n' +
    '        const botId = botIdByContain || (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    "        if (!botId) return { error: '!botId', botId, triggeredByLinkId, botIdByContain, executor, reader }\n" +
    '        const { data: [active] } = await deep.select({\n' +
    '            type_id: Active,\n' +
    '            to_id: botId,\n' +
    '        });\n' +
    "        if (!active) return { error: '!active', botId, triggeredByLinkId }\n" +
    '        const { data: [{ id }] } = await deep.insert({\n' +
    "            type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Apply'),\n" +
    "            from_id: await deep.id('@deep-foundation/deepmemorybot', 'template'),\n" +
    '            to_id: newLink.from_id,\n' +
    '            ...(gptconv ? {\n' +
    '                out: { data: {\n' +
    "                    type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Continue'),\n" +
    '                    to_id: gptconv.id,\n' +
    '                    in: { data: {\n' +
    '                        type_id: Contain,\n' +
    '                        from_id: active.id\n' +
    '                    } },\n' +
    '                } }\n' +
    '            } : {}),\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        const { data: [apply] } = await deep.select(id);\n' +
    '        \n' +
    '        const response = await new Promise(async (res, rej) => {\n' +
    '            let counter = 0;\n' +
    '            const interval = setInterval(async () => {\n' +
    '                const { data: [response] } = await deep.Traveler([apply])\n' +
    "                    .out({ type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Result') })\n" +
    "                    .to().in({ type_id: await deep.id('@deep-foundation/chatgpt-azure', 'Reply') }).from()\n" +
    '                    .select();\n' +
    '                if (response) res(response);\n' +
    '                else {\n' +
    '                    if (counter > 500) {\n' +
    '                        clearInterval(interval);\n' +
    '                        rej(new Error(`timeout ${counter} times`));\n' +
    '                    } else {\n' +
    '                        counter++;\n' +
    '                    }\n' +
    '                }\n' +
    '            }, 1000);\n' +
    '        });\n' +
    '\n' +
    "        if (!response) return { error: '!response' };\n" +
    '\n' +
    '        await deep.insert({\n' +
    '            type_id: Reply,\n' +
    '            from_id: response?.id,\n' +
    '            to_id: newLink.from_id,\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    } else {\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTU3OSJ9LCJpYXQiOjE3MjAwNjg4MzF9.fKuplyExQtyR25FyML9Yq0kLRTf7hrdCR23I0H4GSbI',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 16515,
    oldLink: null,
    newLink: {
      from_id: 16527,
      type_id: 1096,
      id: 16529,
      to_id: 16519,
      value: null
    },
    promiseId: 16532,
    selectorId: 1566,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
call options {
  code: 'async ({ require, deep, data: { newLink, triggeredByLinkId } }) => {\r\n' +
    '    const Conversation = await deep.id("@deep-foundation/chatgpt-azure", "Conversation");\r\n' +
    '    const Result = await deep.id("@deep-foundation/chatgpt-azure-templates", "Result");\r\n' +
    '    const Message = await deep.id("@deep-foundation/messaging", "Message");\r\n' +
    '    const Contain = await deep.id("@deep-foundation/core", "Contain");\r\n' +
    `    const Reply = await deep.id("@deep-foundation/chatgpt-azure", 'Reply');\r\n` +
    '    const Continue = await deep.id(deep.linkId, "Continue");\r\n' +
    '\r\n' +
    '    const { data: [template] } = await deep.select(newLink.from_id);\r\n' +
    '    const { data: [cont] } = await deep.select({\r\n' +
    '        type_id: Continue,\r\n' +
    '        from_id: newLink.id,\r\n' +
    '    });\r\n' +
    '\r\n' +
    '    const evalTemplate = async (options) => {\r\n' +
    '        const { linkId, deep, template } = options;\r\n' +
    "        const result = eval('(async () => (`'+template+'`))()');\r\n" +
    '        return result;\r\n' +
    '    }\r\n' +
    '\r\n' +
    '    const linkId = newLink.to_id;\r\n' +
    "    const value = template?.value?.value || '';\r\n" +
    '    const result = await evalTemplate({ linkId, deep, template: value });\r\n' +
    '\r\n' +
    '    const { data: [{ id: messageLinkId }] } = await deep.insert({\r\n' +
    '        string: { data: { value: result } },\r\n' +
    '        type_id: Message,\r\n' +
    '        in: { data: [\r\n' +
    '            {\r\n' +
    '                type_id: Contain,\r\n' +
    '                from_id: newLink.from_id,\r\n' +
    '            },\r\n' +
    '            {\r\n' +
    '                type_id: Result,\r\n' +
    '                from_id: newLink.id,\r\n' +
    '                in: {\r\n' +
    '                    data: {\r\n' +
    '                        type_id: Contain,\r\n' +
    '                        from_id: newLink.from_id,\r\n' +
    '                    },\r\n' +
    '                },\r\n' +
    '            },\r\n' +
    '        ] },\r\n' +
    '    });\r\n' +
    '\r\n' +
    '    await deep.insert({\r\n' +
    '        type_id: Reply,\r\n' +
    '        from_id: messageLinkId,\r\n' +
    '        ...(cont ? {\r\n' +
    '            to_id: cont.to_id,\r\n' +
    '        } : {\r\n' +
    '            to: { data: {\r\n' +
    '                type_id: Conversation,\r\n' +
    '                in: { data: {\r\n' +
    '                    type_id: Contain,\r\n' +
    '                    from_id: newLink.id,\r\n' +
    '                } },\r\n' +
    '            } },\r\n' +
    '        }),\r\n' +
    '        in: { data: [{\r\n' +
    '                type_id: Contain,\r\n' +
    '                from_id: newLink.id,\r\n' +
    '        }] }\r\n' +
    '    });\r\n' +
    '\r\n' +
    '    return {\r\n' +
    '        templateId: linkId,\r\n' +
    '        template: template?.value?.value,\r\n' +
    '        result,\r\n' +
    '    };\r\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTM1OCJ9LCJpYXQiOjE3MjAwNjg4MzF9._wsiIsKc6Ld9c-rF8-C-8trHpR5oCDuwVuegYi2Oh9M',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1579,
    oldLink: null,
    newLink: {
      from_id: 1574,
      type_id: 1353,
      id: 16546,
      to_id: 16527,
      value: null
    },
    promiseId: 16547,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
call result {
  templateId: 16527,
  template: '${await (async () => {\n' +
    '    const message = (await deep.select(linkId))?.data?.[0];\n' +
    '    const user = message ? (await deep.select({\n' +
    "        type_id: deep.idLocal('@deep-foundation/core', 'User'),\n" +
    '        out: {\n' +
    "            type_id: deep.idLocal('@deep-foundation/core', 'Contain'),\n" +
    '            to_id: message?.id,\n' +
    '        },\n' +
    '    }))?.data?.[0] : undefined;\n' +
    '    return `\n' +
    '${user ? `\n' +
    'user: ${JSON.stringify(user)}\n' +
    'name: ${await deep.name(user?.id)}\n' +
    "` : ''}\n" +
    'message: ${message?.value?.value}\n' +
    '    `;\n' +
    '})()}',
  result: '\n' +
    '\n' +
    'user: {"id":16515,"type_id":22,"from_id":0,"to_id":0,"value":null,"__typename":"links"}\n' +
    'name: 684891878\n' +
    '\n' +
    'message: Как собрать avent молокоотсос\n' +
    '    '
}
call options {
  code: 'async ({ data: { newLink: reply, triggeredByLinkId }, deep }) => {\n' +
    '  const ml = deep.minilinks;\n' +
    '\n' +
    '  const startTime = Date.now();\n' +
    "  const axios = await deep.import('axios');\n" +
    '\n' +
    "  const ChatGPT = await deep.id(deep.linkId, 'ChatGPT');\n" +
    "  const Conversation = await deep.id(deep.linkId, 'Conversation');\n" +
    "  const ApiKey = await deep.id('@deep-foundation/openai', 'ApiKey');\n" +
    "  const UsesApiKey = await deep.id('@deep-foundation/openai', 'UsesApiKey');\n" +
    "  const Model = await deep.id('@deep-foundation/openai', 'Model');\n" +
    "  const UsesModel = await deep.id('@deep-foundation/openai', 'UsesModel');\n" +
    "  const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "  const Reply = await deep.id('@deep-foundation/chatgpt-azure', 'Reply');\n" +
    "  const Author = await deep.id('@deep-foundation/messaging', 'Author');\n" +
    "  const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "  const System = await deep.id('@deep-foundation/chatgpt-azure', 'System');\n" +
    '  const Tokens = await deep.id("@deep-foundation/tokens", "Tokens")\n' +
    '  const ProvidedBy = await deep.id("@deep-foundation/chatgpt-azure", "ProvidedBy")\n' +
    '\n' +
    '  await deep.await(reply.from_id);  const { data: [message] } = await deep.select({\n' +
    '    id: reply.from_id,\n' +
    '    _not: { out: { to_id: ChatGPT, type_id: Author } },\n' +
    '  });\n' +
    "  if (!message) return 'No need to react to message of this reply.';\n" +
    '  if (!message.value?.value) throw new Error(`Message (##${message?.id}) must have a value`);\n' +
    '\n' +
    '  ml.apply(await deep.select({\n' +
    '    type_id: ApiKey,\n' +
    '    in: { from_id: triggeredByLinkId, type_id: UsesApiKey },\n' +
    '    return: {\n' +
    "      uses: { relation: 'in', type_id: UsesApiKey },\n" +
    '    },\n' +
    "  }), 'apikey');\n" +
    '\n' +
    '  const apikeys = ml.select({ type_id: ApiKey });\n' +
    '  const useses = ml.select({ tyoe_id: UsesApiKey, to: { type_id: ApiKey } });\n' +
    '  \n' +
    '  if (!apikeys.length) throw new Error(`ApiKey not founded`);\n' +
    '  if (useses.length > 1) throw new Error(`More than 1 links of type UsesApiKey are found`);\n' +
    '  if (!apikeys[0]?.value?.value) throw new Error(`ApiKey ##${apikeys[0]?.id} has no value`);\n' +
    '\n' +
    '  const { data: [conversation] } = await deep.select({\n' +
    '    type_id: Conversation,\n' +
    '    down: { tree_id: messagingTree, link_id: reply.id }\n' +
    '  });\n' +
    "  if (!conversation) return 'Conversation upper not founded.';\n" +
    '\n' +
    '  const messagesByReply = await deep.select({\n' +
    '    type_id: Message,\n' +
    '    down: { tree_id: messagingTree, link_id: reply.from_id },\n' +
    "    order_by: { id: 'asc' },\n" +
    '    return: {\n' +
    "      authors: { relation: 'out', type_id: Author },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '    }\n' +
    '  });\n' +
    "  ml.apply(messagesByReply, 'messagesByReply');\n" +
    '\n' +
    '  const messagesById = await deep.select({\n' +
    '    id: { _nin: messagesByReply.data.map(l => l.id) },\n' +
    '    type_id: Message,\n' +
    '    up: { tree_id: messagingTree, parent_id: conversation.id },\n' +
    "    order_by: { id: 'asc' },\n" +
    '    return: {\n' +
    "      authors: { relation: 'out', type_id: Author },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '    }\n' +
    '  });\n' +
    "  ml.apply(messagesById, 'messagesById');\n" +
    '\n' +
    '  const messagesToSend = [...messagesById.data, ...messagesByReply.data];\n' +
    '  const models = await deep.select({\n' +
    '    type_id: Model,\n' +
    '    in: { type_id: UsesModel, from_id: { _in: [conversation.id, triggeredByLinkId] } },\n' +
    '    return: {\n' +
    "      usesModel: { relation: 'in', type_id: UsesModel },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '      providedBy: {\n' +
    "        relation: 'out', type_id: ProvidedBy,\n" +
    '        return: {\n' +
    "          endpoint: { relation: 'to' }\n" +
    '        },\n' +
    '      },\n' +
    '    },\n' +
    '  });\n' +
    "  ml.apply(models, 'models');\n" +
    '\n' +
    '  const [userLinkedModel] = ml.select({ type_id: Model, in: { type_id: UsesModel, from_id: triggeredByLinkId } });\n' +
    '  if (!userLinkedModel) throw new Error(`UsersModel from triggeredByLinkId ${triggeredByLinkId} to Model not founded.`);\n' +
    '  const [userLinkedModelTokens] = ml.select({ type_id: Tokens, from_id: userLinkedModel?.id });\n' +
    '  const [linkedModel] = ml.select({ type_id: Model, in: { type_id: UsesModel, from_id: conversation.id } });\n' +
    '  \n' +
    '  const MAX_TOKENS = userLinkedModelTokens?.value?.value;\n' +
    '  if (!MAX_TOKENS) throw new Error(`MAX_TOKENS Tokens (##${userLinkedModelTokens?.id}) .value from model not founded.`);\n' +
    '  \n' +
    '  const endpoint = ml.select({ in: { type_id: ProvidedBy } })[0];\n' +
    '  const API_ENDPOINT = endpoint?.value?.value;\n' +
    '  if (!API_ENDPOINT) throw new Error(`API_ENDPOINT Endpoint (##${endpoint?.id}) instance.value nout founded.`);\n' +
    '  \n' +
    '  const model = linkedModel?.value?.value || userLinkedModel?.value?.value;\n' +
    '  if(!model) throw new Error(`UsersModel from conversation.id (##${conversation.id}) to Model not founded.`);\n' +
    '\n' +
    '  let preparedMessages = messagesToSend.map((link) => {\n' +
    '    const tokens = ml.select({ type_id: Tokens, from_id: link.id })[0]?.value?.value;\n' +
    '    return {\n' +
    "      role: ml.select({ type_id: Author, from_id: link.id })[0]?.to_id === ChatGPT ? 'assistant' : 'user',\n" +
    '      content: link.value.value,\n' +
    '      tokens: ml.select({ type_id: Tokens, from_id: link.id })[0]?.value?.value,\n' +
    '    }\n' +
    '  });\n' +
    '\n' +
    '  const systems = await deep.select({\n' +
    '    type_id: System, to_id: { _in: [triggeredByLinkId, conversation.id] },\n' +
    '    return: {\n' +
    "      message: { relation: 'from' },\n" +
    "      conversation: { relation: 'to' },\n" +
    "      tokens: { relation: 'in', type_id: Tokens },\n" +
    '    },\n' +
    '  });\n' +
    "  ml.apply(systems, 'systems');\n" +
    '\n' +
    '  const conversationSystem = ml.select({ type_id: System, to_id: conversation.id })?.[0];\n' +
    '  if (!!conversationSystem && !conversationSystem?.value?.value) throw new Error(`System .value to conversation not defined`);\n' +
    '  const userSystems = ml.select({ type_id: System, to_id: triggeredByLinkId });\n' +
    '  if (userSystems.length > 1) throw new Error("Multiple system messages linked to the user are found");\n' +
    '  const userSystem = userSystems[0];\n' +
    '\n' +
    '  const systemMessage = conversationSystem?.from || userSystem?.from;\n' +
    '  if (systemMessage) {\n' +
    '    if (!systemMessage?.value?.value) throw new Error(`System (##${systemMessage?.id}) .from Message.value not founded`);\n' +
    "    preparedMessages.unshift({ role: 'system', content: systemMessage?.value?.value });\n" +
    '  }\n' +
    '\n' +
    '  const tokenLimit = MAX_TOKENS * 7 / 8;\n' +
    '  let totalTokens = 0;\n' +
    '  let messages = [];\n' +
    '\n' +
    '  for (let i = preparedMessages.length - 1; i >= 0; i--) {\n' +
    '    const message = preparedMessages[i];\n' +
    "    if (message.role === 'system' || totalTokens + message.tokens <= tokenLimit) {\n" +
    '      messages.unshift({ role: message.role, content: message.content });\n' +
    '      totalTokens += message.tokens;\n' +
    '    } else {\n' +
    '      break;\n' +
    '    }\n' +
    '  }\n' +
    '\n' +
    '  let response;\n' +
    '  try {\n' +
    '    response = await axios.post(API_ENDPOINT, { messages }, {\n' +
    "      headers: { 'Content-Type': 'application/json', 'api-key': apikeys[0]?.value?.value },\n" +
    '    });\n' +
    '  } catch (error) {\n' +
    "    console.error('Error making API call:', error.response ? error.response.data : error.message);\n" +
    '  }\n' +
    '\n' +
    '  const content = response.data.choices[0]?.message?.content;\n' +
    '  await deep.insert({\n' +
    '    type_id: Message,\n' +
    '    string: { data: { value: content } },\n' +
    '    out: { data: [\n' +
    '      { type_id: Author, to_id: ChatGPT },\n' +
    '      { type_id: Reply, to_id: reply.from_id },\n' +
    '    ] },\n' +
    '  });\n' +
    '\n' +
    '  const endTime = Date.now();\n' +
    '  const duration = (endTime - startTime) / 1000;\n' +
    '\n' +
    '  ml.remove(Object.keys(ml.byId));\n' +
    '\n' +
    '  return {\n' +
    '    request: { model, messages },\n' +
    '    response: response.data,\n' +
    '    duration, totalTokens,\n' +
    '  };\n' +
    '};',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTIwOCJ9LCJpYXQiOjE3MjAwNjg4MzJ9.PaQvTRM8D_k8rYH4mL8sVkDhsKSQYVbxe8Ol5qpvDqU',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1358,
    oldLink: null,
    newLink: {
      from_id: 16550,
      type_id: 1191,
      id: 16558,
      to_id: 16556,
      value: null
    },
    promiseId: 16559,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
call result {
  request: { model: 'gpt-4o', messages: [ [Object], [Object] ] },
  response: {
    choices: [ [Object] ],
    created: 1720068837,
    id: 'chatcmpl-9h8lh8pONXFc0KE4ED0oStdAogvy6',
    model: 'gpt-4o-2024-05-13',
    object: 'chat.completion',
    system_fingerprint: 'fp_abc28019ad',
    usage: { completion_tokens: 443, prompt_tokens: 4850, total_tokens: 5293 }
  },
  duration: 15.079,
  totalTokens: NaN
}
call result { botId: 1613, triggeredByLinkId: 16515 }
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
call options {
  code: 'async ({ data: { newLink: reply, triggeredByLinkId }, deep }) => {\n' +
    '  const ml = deep.minilinks;\n' +
    '\n' +
    '  const startTime = Date.now();\n' +
    "  const axios = await deep.import('axios');\n" +
    '\n' +
    "  const ChatGPT = await deep.id(deep.linkId, 'ChatGPT');\n" +
    "  const Conversation = await deep.id(deep.linkId, 'Conversation');\n" +
    "  const ApiKey = await deep.id('@deep-foundation/openai', 'ApiKey');\n" +
    "  const UsesApiKey = await deep.id('@deep-foundation/openai', 'UsesApiKey');\n" +
    "  const Model = await deep.id('@deep-foundation/openai', 'Model');\n" +
    "  const UsesModel = await deep.id('@deep-foundation/openai', 'UsesModel');\n" +
    "  const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "  const Reply = await deep.id('@deep-foundation/chatgpt-azure', 'Reply');\n" +
    "  const Author = await deep.id('@deep-foundation/messaging', 'Author');\n" +
    "  const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "  const System = await deep.id('@deep-foundation/chatgpt-azure', 'System');\n" +
    '  const Tokens = await deep.id("@deep-foundation/tokens", "Tokens")\n' +
    '  const ProvidedBy = await deep.id("@deep-foundation/chatgpt-azure", "ProvidedBy")\n' +
    '\n' +
    '  await deep.await(reply.from_id);  const { data: [message] } = await deep.select({\n' +
    '    id: reply.from_id,\n' +
    '    _not: { out: { to_id: ChatGPT, type_id: Author } },\n' +
    '  });\n' +
    "  if (!message) return 'No need to react to message of this reply.';\n" +
    '  if (!message.value?.value) throw new Error(`Message (##${message?.id}) must have a value`);\n' +
    '\n' +
    '  ml.apply(await deep.select({\n' +
    '    type_id: ApiKey,\n' +
    '    in: { from_id: triggeredByLinkId, type_id: UsesApiKey },\n' +
    '    return: {\n' +
    "      uses: { relation: 'in', type_id: UsesApiKey },\n" +
    '    },\n' +
    "  }), 'apikey');\n" +
    '\n' +
    '  const apikeys = ml.select({ type_id: ApiKey });\n' +
    '  const useses = ml.select({ tyoe_id: UsesApiKey, to: { type_id: ApiKey } });\n' +
    '  \n' +
    '  if (!apikeys.length) throw new Error(`ApiKey not founded`);\n' +
    '  if (useses.length > 1) throw new Error(`More than 1 links of type UsesApiKey are found`);\n' +
    '  if (!apikeys[0]?.value?.value) throw new Error(`ApiKey ##${apikeys[0]?.id} has no value`);\n' +
    '\n' +
    '  const { data: [conversation] } = await deep.select({\n' +
    '    type_id: Conversation,\n' +
    '    down: { tree_id: messagingTree, link_id: reply.id }\n' +
    '  });\n' +
    "  if (!conversation) return 'Conversation upper not founded.';\n" +
    '\n' +
    '  const messagesByReply = await deep.select({\n' +
    '    type_id: Message,\n' +
    '    down: { tree_id: messagingTree, link_id: reply.from_id },\n' +
    "    order_by: { id: 'asc' },\n" +
    '    return: {\n' +
    "      authors: { relation: 'out', type_id: Author },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '    }\n' +
    '  });\n' +
    "  ml.apply(messagesByReply, 'messagesByReply');\n" +
    '\n' +
    '  const messagesById = await deep.select({\n' +
    '    id: { _nin: messagesByReply.data.map(l => l.id) },\n' +
    '    type_id: Message,\n' +
    '    up: { tree_id: messagingTree, parent_id: conversation.id },\n' +
    "    order_by: { id: 'asc' },\n" +
    '    return: {\n' +
    "      authors: { relation: 'out', type_id: Author },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '    }\n' +
    '  });\n' +
    "  ml.apply(messagesById, 'messagesById');\n" +
    '\n' +
    '  const messagesToSend = [...messagesById.data, ...messagesByReply.data];\n' +
    '  const models = await deep.select({\n' +
    '    type_id: Model,\n' +
    '    in: { type_id: UsesModel, from_id: { _in: [conversation.id, triggeredByLinkId] } },\n' +
    '    return: {\n' +
    "      usesModel: { relation: 'in', type_id: UsesModel },\n" +
    "      tokens: { relation: 'out', type_id: Tokens },\n" +
    '      providedBy: {\n' +
    "        relation: 'out', type_id: ProvidedBy,\n" +
    '        return: {\n' +
    "          endpoint: { relation: 'to' }\n" +
    '        },\n' +
    '      },\n' +
    '    },\n' +
    '  });\n' +
    "  ml.apply(models, 'models');\n" +
    '\n' +
    '  const [userLinkedModel] = ml.select({ type_id: Model, in: { type_id: UsesModel, from_id: triggeredByLinkId } });\n' +
    '  if (!userLinkedModel) throw new Error(`UsersModel from triggeredByLinkId ${triggeredByLinkId} to Model not founded.`);\n' +
    '  const [userLinkedModelTokens] = ml.select({ type_id: Tokens, from_id: userLinkedModel?.id });\n' +
    '  const [linkedModel] = ml.select({ type_id: Model, in: { type_id: UsesModel, from_id: conversation.id } });\n' +
    '  \n' +
    '  const MAX_TOKENS = userLinkedModelTokens?.value?.value;\n' +
    '  if (!MAX_TOKENS) throw new Error(`MAX_TOKENS Tokens (##${userLinkedModelTokens?.id}) .value from model not founded.`);\n' +
    '  \n' +
    '  const endpoint = ml.select({ in: { type_id: ProvidedBy } })[0];\n' +
    '  const API_ENDPOINT = endpoint?.value?.value;\n' +
    '  if (!API_ENDPOINT) throw new Error(`API_ENDPOINT Endpoint (##${endpoint?.id}) instance.value nout founded.`);\n' +
    '  \n' +
    '  const model = linkedModel?.value?.value || userLinkedModel?.value?.value;\n' +
    '  if(!model) throw new Error(`UsersModel from conversation.id (##${conversation.id}) to Model not founded.`);\n' +
    '\n' +
    '  let preparedMessages = messagesToSend.map((link) => {\n' +
    '    const tokens = ml.select({ type_id: Tokens, from_id: link.id })[0]?.value?.value;\n' +
    '    return {\n' +
    "      role: ml.select({ type_id: Author, from_id: link.id })[0]?.to_id === ChatGPT ? 'assistant' : 'user',\n" +
    '      content: link.value.value,\n' +
    '      tokens: ml.select({ type_id: Tokens, from_id: link.id })[0]?.value?.value,\n' +
    '    }\n' +
    '  });\n' +
    '\n' +
    '  const systems = await deep.select({\n' +
    '    type_id: System, to_id: { _in: [triggeredByLinkId, conversation.id] },\n' +
    '    return: {\n' +
    "      message: { relation: 'from' },\n" +
    "      conversation: { relation: 'to' },\n" +
    "      tokens: { relation: 'in', type_id: Tokens },\n" +
    '    },\n' +
    '  });\n' +
    "  ml.apply(systems, 'systems');\n" +
    '\n' +
    '  const conversationSystem = ml.select({ type_id: System, to_id: conversation.id })?.[0];\n' +
    '  if (!!conversationSystem && !conversationSystem?.value?.value) throw new Error(`System .value to conversation not defined`);\n' +
    '  const userSystems = ml.select({ type_id: System, to_id: triggeredByLinkId });\n' +
    '  if (userSystems.length > 1) throw new Error("Multiple system messages linked to the user are found");\n' +
    '  const userSystem = userSystems[0];\n' +
    '\n' +
    '  const systemMessage = conversationSystem?.from || userSystem?.from;\n' +
    '  if (systemMessage) {\n' +
    '    if (!systemMessage?.value?.value) throw new Error(`System (##${systemMessage?.id}) .from Message.value not founded`);\n' +
    "    preparedMessages.unshift({ role: 'system', content: systemMessage?.value?.value });\n" +
    '  }\n' +
    '\n' +
    '  const tokenLimit = MAX_TOKENS * 7 / 8;\n' +
    '  let totalTokens = 0;\n' +
    '  let messages = [];\n' +
    '\n' +
    '  for (let i = preparedMessages.length - 1; i >= 0; i--) {\n' +
    '    const message = preparedMessages[i];\n' +
    "    if (message.role === 'system' || totalTokens + message.tokens <= tokenLimit) {\n" +
    '      messages.unshift({ role: message.role, content: message.content });\n' +
    '      totalTokens += message.tokens;\n' +
    '    } else {\n' +
    '      break;\n' +
    '    }\n' +
    '  }\n' +
    '\n' +
    '  let response;\n' +
    '  try {\n' +
    '    response = await axios.post(API_ENDPOINT, { messages }, {\n' +
    "      headers: { 'Content-Type': 'application/json', 'api-key': apikeys[0]?.value?.value },\n" +
    '    });\n' +
    '  } catch (error) {\n' +
    "    console.error('Error making API call:', error.response ? error.response.data : error.message);\n" +
    '  }\n' +
    '\n' +
    '  const content = response.data.choices[0]?.message?.content;\n' +
    '  await deep.insert({\n' +
    '    type_id: Message,\n' +
    '    string: { data: { value: content } },\n' +
    '    out: { data: [\n' +
    '      { type_id: Author, to_id: ChatGPT },\n' +
    '      { type_id: Reply, to_id: reply.from_id },\n' +
    '    ] },\n' +
    '  });\n' +
    '\n' +
    '  const endTime = Date.now();\n' +
    '  const duration = (endTime - startTime) / 1000;\n' +
    '\n' +
    '  ml.remove(Object.keys(ml.byId));\n' +
    '\n' +
    '  return {\n' +
    '    request: { model, messages },\n' +
    '    response: response.data,\n' +
    '    duration, totalTokens,\n' +
    '  };\n' +
    '};',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTIwOCJ9LCJpYXQiOjE3MjAwNjg4NDh9.lFF9wCNMKjX6N9VdYJC0TPiyYJgIYIxesuczO-6k2Vs',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1208,
    oldLink: null,
    newLink: {
      from_id: 16573,
      type_id: 1191,
      id: 16575,
      to_id: 16550,
      value: null
    },
    promiseId: 16576,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId }, require }) => {\n' +
    "    const { Telegraf } = require('telegraf');\n" +
    "    const Markup = require('telegraf/markup');\n" +
    '\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/telegram-bot', 'Active');\n" +
    "    const Conversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    const HandleTelegramBotOut = await deep.id('@deep-foundation/telegram-bot', 'HandleTelegramBotOut');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    const Contain = deep.idLocal('@deep-foundation/core', 'Contain');\n" +
    '\n' +
    '    function splitStringIntoChunks(str, chunkSize = 4096) {\n' +
    '        const chunks = [];\n' +
    '        for (let i = 0, len = str.length; i < len; i += chunkSize) {\n' +
    '            chunks.push(str.substring(i, i + chunkSize));\n' +
    '        }\n' +
    '        return chunks;\n' +
    '    }\n' +
    '\n' +
    '    const botId = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    if (!botId) {\n' +
    '        const botId = (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const token = (await deep.select({\n' +
    '            type_id: Token,\n' +
    '            in: {\n' +
    '                type_id: Active,\n' +
    '                from: {\n' +
    '                    down: {\n' +
    '                        tree_id: messagingTree,\n' +
    '                        link_id: newLink.id,\n' +
    '                    },\n' +
    '                },\n' +
    '            },\n' +
    '        }))?.data?.[0];\n' +
    '        const conversationId = (await deep.select({\n' +
    '            type_id: Conversation,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    '        const replyToId = newLink.to_id;\n' +
    '\n' +
    '        const message = (await deep.select(newLink.from_id))?.data?.[0];\n' +
    '\n' +
    '        const bot = new Telegraf(token?.value?.value);\n' +
    '\n' +
    '        const { data: handles } = await deep.select({\n' +
    '            type_id: HandleTelegramBotOut,\n' +
    '            from_id: botId,\n' +
    "            order_by: { id: 'asc' },\n" +
    '        });\n' +
    '\n' +
    '        const state = {\n' +
    '            defaultHandling: true,\n' +
    '        };\n' +
    '        const handled = {};\n' +
    '        for (let h in handles) {\n' +
    '            const packageId = (await deep.select({\n' +
    '                out: { type_id: Contain, to_id: handles[h].to_id },\n' +
    '            }))?.data?.[0]?.id;\n' +
    '            if (!packageId) {\n' +
    '                handled[handles[h].to_id] = { error: `!packageId by handler(${handles[h].to_id}).in(Contain).from` };\n' +
    '                continue;\n' +
    '            }\n' +
    '            const hdeep = new deep.DeepClient({\n' +
    '                deep, ...(await deep.jwt({ linkId: packageId }))\n' +
    '            })\n' +
    '            handled[handles[h].to_id] = await hdeep.eval({\n' +
    '                linkId: botId,\n' +
    '                handlerId: handles[h].to_id,\n' +
    '                input: {\n' +
    '                    data: {\n' +
    '                        state,\n' +
    '                        bot,\n' +
    '                        botId,\n' +
    '                        userId: triggeredByLinkId,\n' +
    '                        conversationId,\n' +
    '                        handlerId: handles[h].to_id,\n' +
    '                        reply: newLink,\n' +
    '                        message,\n' +
    '                    },\n' +
    '                },\n' +
    '            });\n' +
    '        }\n' +
    '\n' +
    '        if (state.defaultHandling) {\n' +
    '            const chanks = splitStringIntoChunks(message?.value?.value);\n' +
    '            for (let c in chanks) {\n' +
    '                bot.telegram.sendMessage(\n' +
    '                    await deep.name(conversationId),\n' +
    '                    chanks[c],\n' +
    '                );\n' +
    '            }\n' +
    '        }\n' +
    '\n' +
    '        return {\n' +
    '            botId,\n' +
    '            conversationId,\n' +
    '            replyToId,\n' +
    '            message,\n' +
    '            token,\n' +
    '        };\n' +
    '    } else {\n' +
    '        return { botId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTQ3MSJ9LCJpYXQiOjE3MjAwNjg4NDh9.0r9DK7no0EdRXNlb4TsnFwgkJ1cprkiTB7jAB4itfyI',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1579,
    oldLink: null,
    newLink: {
      from_id: 16573,
      type_id: 1096,
      id: 16583,
      to_id: 16527,
      value: null
    },
    promiseId: 16584,
    selectorId: 1453,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
evalClientHandler value async ({ deep, data: {
    state,
    bot,
    botId,
    userId,
    conversationId,
    handlerId,
    reply,
    message,
} }) => {
    if ((message?.value?.value || '').includes('DEEP_MEMORY_EXECUTE')) {
        const codeMatch = message?.value?.value.matchAll(/```javascript([\s\S]*?)```/g);
        const codes = [...codeMatch].map(c => c[1].trim());
        for (let c in codes) {
            const { data: [{ id: newHandlerId }] } = await deep.insert({
                type_id: deep.idLocal('@deep-foundation/core', 'Handler'),
                to: { data: {
                    type_id: deep.idLocal('@deep-foundation/core', 'SyncTextFile'),
                    string: { data: { value: `async ({ deep, sql }) => { ${codes[c]} }` } },
                    in: { data: {
                        type_id: deep.idLocal('@deep-foundation/core', 'Contain'),
                        from_id: await deep.id('@deep-foundation/deepmemorybot', 'executor'),
                    } },
                } },
                from_id: 83,
                in: { data: {
                    type_id: deep.idLocal('@deep-foundation/core', 'Contain'),
                    from_id: await deep.id('@deep-foundation/deepmemorybot', 'executor'),
                } },
            });
            bot.telegram.sendMessage(
                await deep.name(conversationId),
                codes[c],
                { reply_markup: { inline_keyboard: [[
                    {
                        text: 'Execute',
                        callback_data: JSON.stringify({
                            messageId: message.id,
                            handlerId: newHandlerId,
                        }),
                    },
                ]] } },
            );
        }
    }
}
call result {
  botId: 1613,
  conversationId: 16519,
  replyToId: 16527,
  message: {
    id: 16573,
    type_id: 1094,
    from_id: 0,
    to_id: 0,
    value: {
      id: 1631,
      value: 'Для ответа на ваш вопрос нужно уточнить, о каком именно молокоотсосе Avent идет речь. Однако, я могу предоставить общие инструкции, которые могут подойти для большинства молокоотсосов Avent. Пожалуйста, примите во внимание, что более точные инструкции можно найти в руководстве пользователя конкретного устройства.\n' +
        '\n' +
        '1. **Шаг 1: Подготовка деталей**\n' +
        '    - Достаньте все детали молокоотсоса из упаковки и внимательно осмотрите их, чтобы убедиться, что ничего не повреждено.\n' +
        '    - Вымойте все детали, которые контактируют с молоком, в горячей мыльной воде и хорошо их прополощите.\n' +
        '\n' +
        '2. **Шаг 2: Сборка молокоотсоса**\n' +
        '    - Сначала соберите основную часть молокоотсоса, включающую мембрану и воронку.\n' +
        '    - Установите клапан и мембрану на место, чтобы обеспечить герметичность.\n' +
        '    - Если в комплекте есть бутылочка для сбора молока, прикрутите ее к основной части молокоотсоса.\n' +
        '    - Убедитесь, что все детали надежно закреплены и правильно установлены.\n' +
        '\n' +
        '3. **Шаг 3: Использование**\n' +
        '    - Поместите воронку молокоотсоса на грудь так, чтобы центр воронки был направлен на сосок.\n' +
        '    - Начните процесс сцеживания, следуя инструкциям в руководстве пользователя вашего конкретного молокоотсоса: это может быть либо ручной насос, либо автоматическое устройство с кнопками управления.\n' +
        '\n' +
        '4. **Шаг 4: Стерилизация**\n' +
        '    - После использования молокоотсоса, разберите его и снова промойте все детали в горячей мыльной воде.\n' +
        '    - Рекомендуется стерилизовать детали перед следующем использованием; для этого можно использовать горячую воду или специальный стерилизатор.\n' +
        '\n' +
        'Если нужны более точные инструкции или у вас возникли проблемы со сборкой, пожалуйста, уточните модель молокоотсоса Avent или обратитесь к руководству пользователя.',
      link_id: 16573
    },
    __typename: 'links'
  },
  token: {
    id: 1619,
    type_id: 1443,
    from_id: 0,
    to_id: 0,
    value: {
      id: 622,
      value: '7089114368:AAFxnFeKHiz37jn_Tph3KD7QSjNmLFTWLYU',
      link_id: 1619
    },
    __typename: 'links'
  }
}
call options {
  code: 'async ({ deep, data: { newLink, triggeredByLinkId } }) => {\n' +
    "    const Bot = await deep.id('@deep-foundation/telegram-bot', 'Bot');\n" +
    "    const Token = await deep.id('@deep-foundation/telegram-bot', 'Token');\n" +
    "    const Active = await deep.id('@deep-foundation/deepmemorybot', 'Active');\n" +
    "    const Contain = await deep.id('@deep-foundation/core', 'Contain');\n" +
    "    const Message = await deep.id('@deep-foundation/messaging', 'Message');\n" +
    "    const messagingTree = await deep.id('@deep-foundation/messaging', 'messagingTree');\n" +
    "    const Reply = await deep.id('@deep-foundation/messaging', 'Reply');\n" +
    "    const containTree = deep.idLocal('@deep-foundation/core', 'containTree');\n" +
    "    var bConversation = await deep.id('@deep-foundation/telegram-bot', 'Conversation');\n" +
    "    var gptConversation = await deep.id('@deep-foundation/chatgpt-azure', 'Conversation');\n" +
    '\n' +
    "    const reader = await deep.id('@deep-foundation/deepmemorybot', 'reader');\n" +
    "    const executor = await deep.id('@deep-foundation/deepmemorybot', 'executor');\n" +
    '\n' +
    '    const botIdByContain = (await deep.select({\n' +
    '        type_id: Bot,\n' +
    '        down: {\n' +
    '            tree_id: containTree,\n' +
    '            link_id: triggeredByLinkId\n' +
    '        },\n' +
    '    }))?.data?.[0]?.id;\n' +
    '    // found gpt convesations before\n' +
    '    var { data: [bconv] } = await deep.select({ type_id: bConversation, down: { tree_id: messagingTree, link_id: newLink.id } });\n' +
    '    const gptconv = bconv ? (await deep.select({\n' +
    '        type_id: gptConversation,\n' +
    '        down: {\n' +
    '            tree_id: messagingTree,\n' +
    '            link: {\n' +
    '                up: {\n' +
    '                    tree_id: messagingTree,\n' +
    '                    parent_id: bconv.id,\n' +
    '                },\n' +
    '            },\n' +
    '        },\n' +
    '    }))?.data?.[0] : undefined;\n' +
    '    // const conversationId = (await deep.select({\n' +
    '    //     type_id: Conversation,\n' +
    '    //     down: {\n' +
    '    //         tree_id: messagingTree,\n' +
    '    //         link_id: newLink.id,\n' +
    '    //     },\n' +
    '    // }))?.data?.[0]?.id;\n' +
    '    if (!!botIdByContain || triggeredByLinkId == reader || triggeredByLinkId == executor) {\n' +
    '        const botId = botIdByContain || (await deep.select({\n' +
    '            type_id: Bot,\n' +
    '            down: {\n' +
    '                tree_id: messagingTree,\n' +
    '                link_id: newLink.id,\n' +
    '            },\n' +
    '        }))?.data?.[0]?.id;\n' +
    "        if (!botId) return { error: '!botId', botId, triggeredByLinkId, botIdByContain, executor, reader }\n" +
    '        const { data: [active] } = await deep.select({\n' +
    '            type_id: Active,\n' +
    '            to_id: botId,\n' +
    '        });\n' +
    "        if (!active) return { error: '!active', botId, triggeredByLinkId }\n" +
    '        const { data: [{ id }] } = await deep.insert({\n' +
    "            type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Apply'),\n" +
    "            from_id: await deep.id('@deep-foundation/deepmemorybot', 'template'),\n" +
    '            to_id: newLink.from_id,\n' +
    '            ...(gptconv ? {\n' +
    '                out: { data: {\n' +
    "                    type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Continue'),\n" +
    '                    to_id: gptconv.id,\n' +
    '                    in: { data: {\n' +
    '                        type_id: Contain,\n' +
    '                        from_id: active.id\n' +
    '                    } },\n' +
    '                } }\n' +
    '            } : {}),\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        const { data: [apply] } = await deep.select(id);\n' +
    '        \n' +
    '        const response = await new Promise(async (res, rej) => {\n' +
    '            let counter = 0;\n' +
    '            const interval = setInterval(async () => {\n' +
    '                const { data: [response] } = await deep.Traveler([apply])\n' +
    "                    .out({ type_id: await deep.id('@deep-foundation/chatgpt-azure-templates', 'Result') })\n" +
    "                    .to().in({ type_id: await deep.id('@deep-foundation/chatgpt-azure', 'Reply') }).from()\n" +
    '                    .select();\n' +
    '                if (response) res(response);\n' +
    '                else {\n' +
    '                    if (counter > 500) {\n' +
    '                        clearInterval(interval);\n' +
    '                        rej(new Error(`timeout ${counter} times`));\n' +
    '                    } else {\n' +
    '                        counter++;\n' +
    '                    }\n' +
    '                }\n' +
    '            }, 1000);\n' +
    '        });\n' +
    '\n' +
    "        if (!response) return { error: '!response' };\n" +
    '\n' +
    '        await deep.insert({\n' +
    '            type_id: Reply,\n' +
    '            from_id: response?.id,\n' +
    '            to_id: newLink.from_id,\n' +
    '            in: { data: {\n' +
    '                type_id: Contain,\n' +
    '                from_id: active.id\n' +
    '            } },\n' +
    '        });\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    } else {\n' +
    '        return { botId, triggeredByLinkId };\n' +
    '    }\n' +
    '}',
  container: {
    name: 'deep-138d60d2a0fd040bfe13e80d143de80d',
    host: 'localhost',
    port: 40571,
    options: {
      publish: true,
      forceRestart: true,
      handler: 'deepf/js-docker-isolation-provider:main'
    }
  },
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTU3OSJ9LCJpYXQiOjE3MjAwNjg4NDl9.oxnnfbBfr6S0BB1Slx9WGftiqbgNzc6HRspgFcwt68Q',
  secret: 'myadminsecretkey',
  data: {
    triggeredByLinkId: 1579,
    oldLink: null,
    newLink: {
      from_id: 16573,
      type_id: 1096,
      id: 16583,
      to_id: 16527,
      value: null
    },
    promiseId: 16586,
    selectorId: 1566,
    deeplinksUrl: 'https://3006-deepfoundation-dev-qrmjcgwtq6w.ws-eu115.gitpod.io'
  }
}
rejected {
  name: 'ReferenceError',
  message: 'botId is not defined',
  stack: 'ReferenceError: botId is not defined\n' +
    '    at eval (eval at memoized (/node_modules/lodash/memoize.js:62:23), <anonymous>:111:18)\n' +
    '    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)'
}
call result No need to react to message of this reply.
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
http call options {
  jwt: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2hhc3VyYS5pby9qd3QvY2xhaW1zIjp7IngtaGFzdXJhLWFsbG93ZWQtcm9sZXMiOlsiYWRtaW4iXSwieC1oYXN1cmEtZGVmYXVsdC1yb2xlIjoiYWRtaW4iLCJ4LWhhc3VyYS11c2VyLWlkIjoiMTc3MiJ9LCJpYXQiOjE3MjAwNjg4MTN9.lyffGFMrRZJcTwE09dbUpMYDJGOuUPOn8pRx-wvb_zs',
  code: 'async (req, res, next, { deep, require, gql }) => {\n' +
    "    const { PassThrough, Readable } = require('stream');\n" +
    "    const express = require('express');\n" +
    "    const http = require('http');\n" +
    "    const ApolloServer = require('apollo-server-express').ApolloServer;\n" +
    "    const { ApolloServerPluginDrainHttpServer, ApolloServerPluginLandingPageGraphQLPlayground } = require('apollo-server-core');\n" +
    "    const axios = require('axios');\n" +
    "    const ffmpeg = require('fluent-ffmpeg');\n" +
    "    const FormData = require('form-data');\n" +
    '\n' +
    '    function base64ToStream(base64String) {\n' +
    "        const base64Data = base64String.replace(/^data:[^;]+;base64,/, '');\n" +
    "        const binaryData = Buffer.from(base64Data, 'base64');\n" +
    '        const stream = new Readable();\n' +
    '\n' +
    '        stream.push(binaryData);\n' +
    '        stream.push(null);\n' +
    '\n' +
    '        return stream;\n' +
    '    }\n' +
    '\n' +
    '    const typeDefs = `\n' +
    '        input Voice {\n' +
    '            id: Int!\n' +
    '            record: String!\n' +
    '            duration: Float!\n' +
    '            mimeType: String!\n' +
    '        }\n' +
    '        type Query { deepmemo_upload(voice: Voice!): String }\n' +
    '    `;\n' +
    '\n' +
    '    const resolvers = {\n' +
    '        Query: { deepmemo_upload: async (parent, { voice: {\n' +
    '            id, record, duration, mimeType\n' +
    '        } }, contextValue, info) => {\n' +
    '            let inputFormat;\n' +
    "            if (mimeType.includes('audio/webm')) {\n" +
    "                inputFormat = 'webm';\n" +
    "            } else if (mimeType.includes('audio/aac')) {\n" +
    "                inputFormat = 'aac';\n" +
    "            } else if (mimeType.includes('audio/mp4')) {\n" +
    "                inputFormat = 'mp4';\n" +
    "            } else return 'not supported type';\n" +
    '            return new Promise((res, rej) => {\n' +
    '                    const stream = new PassThrough();\n' +
    '                    let chunkData = [];\n' +
    "                    stream.on('data', chunk => {\n" +
    '                        chunkData.push(chunk);\n' +
    '                    });\n' +
    '                    ffmpeg()\n' +
    '                        .input(base64ToStream(record))\n' +
    '                        .inputFormat(inputFormat)\n' +
    '                        // .output(stream)\n' +
    "                        .outputFormat('mp3')\n" +
    "                        .on('end', () => {\n" +
    '                            stream.end();\n' +
    '                            const byteArray = Buffer.concat(chunkData);\n' +
    '                            const form = new FormData();\n' +
    "                            form.append('file', byteArray, { type: 'audio/mp3', filename: `${id}.mp3` });\n" +
    '                            axios.post(`http://${deep.client.path.slice(0, -4)}/file`, form, {\n' +
    '                                headers: {\n' +
    '                                    linkId: id,\n' +
    '                                    Authorization: contextValue?.headers?.authorization,\n' +
    "                                    // 'Content-Length': dataAsString.length,\n" +
    "                                    // 'Content-Type': 'multipart/form-data'\n" +
    "                                    // 'Content-Type': 'audio/mp3',\n" +
    '                                    ...form.getHeaders(),\n' +
    '                                },\n' +
    '                            })\n' +
    '                                .then((r) => {\n' +
    "                                    res('done');\n" +
    '                                })\n' +
    '                                .catch((e) => {\n' +
    '                                    console.error(e);\n' +
    "                                    rej('error');\n" +
    '                                });\n' +
    '                        })\n' +
    '                        .pipe(stream, { end: true });\n' +
    '                        // .run();\n' +
    '                // });\n' +
    '            });\n' +
    '        } },\n' +
    '    };\n' +
    '    \n' +
    '    const context = ({ req }) => { return { headers: req.headers }; };\n' +
    '    \n' +
    '    const generateApolloServer = () => {\n' +
    '        return new ApolloServer({\n' +
    '            introspection: true,\n' +
    '            typeDefs, \n' +
    '            resolvers,\n' +
    '            context,\n' +
    '            plugins: [\n' +
    '                ApolloServerPluginLandingPageGraphQLPlayground(),\n' +
    '            ],\n' +
    '        });\n' +
    '    };\n' +
    '\n' +
    '    const router = express.Router();\n' +
    '    const apolloServer = generateApolloServer();\n' +
    '    await apolloServer.start();\n' +
    "    apolloServer.applyMiddleware({ app: router, path: '/' });\n" +
    '    router.handle(req, res);\n' +
    '}',
  data: {
    routeString: '/deepmemo-upload',
    path: '/http-call',
    originalUrl: '/deepmemo-upload?query=%7B__typename%7D',
    baseUrl: '/deepmemo-upload',
    handlerId: 1758,
    routeId: 1761,
    router: 1759
  }
}
http call result undefined
